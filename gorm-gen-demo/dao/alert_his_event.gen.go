// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm-gen-demo/model"
)

func newAlertHisEvent(db *gorm.DB, opts ...gen.DOOption) alertHisEvent {
	_alertHisEvent := alertHisEvent{}

	_alertHisEvent.alertHisEventDo.UseDB(db, opts...)
	_alertHisEvent.alertHisEventDo.UseModel(&model.AlertHisEvent{})

	tableName := _alertHisEvent.alertHisEventDo.TableName()
	_alertHisEvent.ALL = field.NewAsterisk(tableName)
	_alertHisEvent.ID = field.NewInt64(tableName, "id")
	_alertHisEvent.IsRecovered = field.NewInt64(tableName, "is_recovered")
	_alertHisEvent.Cate = field.NewString(tableName, "cate")
	_alertHisEvent.DatasourceID = field.NewInt64(tableName, "datasource_id")
	_alertHisEvent.Cluster = field.NewString(tableName, "cluster")
	_alertHisEvent.GroupID = field.NewInt64(tableName, "group_id")
	_alertHisEvent.GroupName = field.NewString(tableName, "group_name")
	_alertHisEvent.Hash = field.NewString(tableName, "hash")
	_alertHisEvent.RuleID = field.NewInt64(tableName, "rule_id")
	_alertHisEvent.RuleName = field.NewString(tableName, "rule_name")
	_alertHisEvent.RuleNote = field.NewString(tableName, "rule_note")
	_alertHisEvent.RuleProd = field.NewString(tableName, "rule_prod")
	_alertHisEvent.RuleAlgo = field.NewString(tableName, "rule_algo")
	_alertHisEvent.Severity = field.NewInt64(tableName, "severity")
	_alertHisEvent.PromForDuration = field.NewInt64(tableName, "prom_for_duration")
	_alertHisEvent.PromQl = field.NewString(tableName, "prom_ql")
	_alertHisEvent.PromEvalInterval = field.NewInt64(tableName, "prom_eval_interval")
	_alertHisEvent.Callbacks = field.NewString(tableName, "callbacks")
	_alertHisEvent.RunbookURL = field.NewString(tableName, "runbook_url")
	_alertHisEvent.NotifyRecovered = field.NewInt64(tableName, "notify_recovered")
	_alertHisEvent.NotifyChannels = field.NewString(tableName, "notify_channels")
	_alertHisEvent.NotifyGroups = field.NewString(tableName, "notify_groups")
	_alertHisEvent.NotifyCurNumber = field.NewInt64(tableName, "notify_cur_number")
	_alertHisEvent.TargetIdent = field.NewString(tableName, "target_ident")
	_alertHisEvent.TargetNote = field.NewString(tableName, "target_note")
	_alertHisEvent.FirstTriggerTime = field.NewInt64(tableName, "first_trigger_time")
	_alertHisEvent.TriggerTime = field.NewInt64(tableName, "trigger_time")
	_alertHisEvent.TriggerValue = field.NewString(tableName, "trigger_value")
	_alertHisEvent.RecoverTime = field.NewInt64(tableName, "recover_time")
	_alertHisEvent.LastEvalTime = field.NewInt64(tableName, "last_eval_time")
	_alertHisEvent.Tags = field.NewString(tableName, "tags")
	_alertHisEvent.Annotations = field.NewString(tableName, "annotations")
	_alertHisEvent.RuleConfig = field.NewString(tableName, "rule_config")

	_alertHisEvent.fillFieldMap()

	return _alertHisEvent
}

type alertHisEvent struct {
	alertHisEventDo

	ALL              field.Asterisk
	ID               field.Int64
	IsRecovered      field.Int64
	Cate             field.String
	DatasourceID     field.Int64 // datasource id
	Cluster          field.String
	GroupID          field.Int64  // busi group id of rule
	GroupName        field.String // busi group name
	Hash             field.String // rule_id + vector_pk
	RuleID           field.Int64
	RuleName         field.String
	RuleNote         field.String
	RuleProd         field.String
	RuleAlgo         field.String
	Severity         field.Int64  // 0:Emergency 1:Warning 2:Notice
	PromForDuration  field.Int64  // prometheus for, unit:s
	PromQl           field.String // promql
	PromEvalInterval field.Int64  // evaluate interval
	Callbacks        field.String // split by space: http://a.com/api/x http://a.com/api/y
	RunbookURL       field.String
	NotifyRecovered  field.Int64  // whether notify when recovery
	NotifyChannels   field.String // split by space: sms voice email dingtalk wecom
	NotifyGroups     field.String // split by space: 233 43
	NotifyCurNumber  field.Int64
	TargetIdent      field.String // target ident, also in tags
	TargetNote       field.String // target note
	FirstTriggerTime field.Int64
	TriggerTime      field.Int64
	TriggerValue     field.String
	RecoverTime      field.Int64
	LastEvalTime     field.Int64  // for time filter
	Tags             field.String // merge data_tags rule_tags, split by ,,
	Annotations      field.String // annotations
	RuleConfig       field.String // annotations

	fieldMap map[string]field.Expr
}

func (a alertHisEvent) Table(newTableName string) *alertHisEvent {
	a.alertHisEventDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a alertHisEvent) As(alias string) *alertHisEvent {
	a.alertHisEventDo.DO = *(a.alertHisEventDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *alertHisEvent) updateTableName(table string) *alertHisEvent {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.IsRecovered = field.NewInt64(table, "is_recovered")
	a.Cate = field.NewString(table, "cate")
	a.DatasourceID = field.NewInt64(table, "datasource_id")
	a.Cluster = field.NewString(table, "cluster")
	a.GroupID = field.NewInt64(table, "group_id")
	a.GroupName = field.NewString(table, "group_name")
	a.Hash = field.NewString(table, "hash")
	a.RuleID = field.NewInt64(table, "rule_id")
	a.RuleName = field.NewString(table, "rule_name")
	a.RuleNote = field.NewString(table, "rule_note")
	a.RuleProd = field.NewString(table, "rule_prod")
	a.RuleAlgo = field.NewString(table, "rule_algo")
	a.Severity = field.NewInt64(table, "severity")
	a.PromForDuration = field.NewInt64(table, "prom_for_duration")
	a.PromQl = field.NewString(table, "prom_ql")
	a.PromEvalInterval = field.NewInt64(table, "prom_eval_interval")
	a.Callbacks = field.NewString(table, "callbacks")
	a.RunbookURL = field.NewString(table, "runbook_url")
	a.NotifyRecovered = field.NewInt64(table, "notify_recovered")
	a.NotifyChannels = field.NewString(table, "notify_channels")
	a.NotifyGroups = field.NewString(table, "notify_groups")
	a.NotifyCurNumber = field.NewInt64(table, "notify_cur_number")
	a.TargetIdent = field.NewString(table, "target_ident")
	a.TargetNote = field.NewString(table, "target_note")
	a.FirstTriggerTime = field.NewInt64(table, "first_trigger_time")
	a.TriggerTime = field.NewInt64(table, "trigger_time")
	a.TriggerValue = field.NewString(table, "trigger_value")
	a.RecoverTime = field.NewInt64(table, "recover_time")
	a.LastEvalTime = field.NewInt64(table, "last_eval_time")
	a.Tags = field.NewString(table, "tags")
	a.Annotations = field.NewString(table, "annotations")
	a.RuleConfig = field.NewString(table, "rule_config")

	a.fillFieldMap()

	return a
}

func (a *alertHisEvent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *alertHisEvent) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 33)
	a.fieldMap["id"] = a.ID
	a.fieldMap["is_recovered"] = a.IsRecovered
	a.fieldMap["cate"] = a.Cate
	a.fieldMap["datasource_id"] = a.DatasourceID
	a.fieldMap["cluster"] = a.Cluster
	a.fieldMap["group_id"] = a.GroupID
	a.fieldMap["group_name"] = a.GroupName
	a.fieldMap["hash"] = a.Hash
	a.fieldMap["rule_id"] = a.RuleID
	a.fieldMap["rule_name"] = a.RuleName
	a.fieldMap["rule_note"] = a.RuleNote
	a.fieldMap["rule_prod"] = a.RuleProd
	a.fieldMap["rule_algo"] = a.RuleAlgo
	a.fieldMap["severity"] = a.Severity
	a.fieldMap["prom_for_duration"] = a.PromForDuration
	a.fieldMap["prom_ql"] = a.PromQl
	a.fieldMap["prom_eval_interval"] = a.PromEvalInterval
	a.fieldMap["callbacks"] = a.Callbacks
	a.fieldMap["runbook_url"] = a.RunbookURL
	a.fieldMap["notify_recovered"] = a.NotifyRecovered
	a.fieldMap["notify_channels"] = a.NotifyChannels
	a.fieldMap["notify_groups"] = a.NotifyGroups
	a.fieldMap["notify_cur_number"] = a.NotifyCurNumber
	a.fieldMap["target_ident"] = a.TargetIdent
	a.fieldMap["target_note"] = a.TargetNote
	a.fieldMap["first_trigger_time"] = a.FirstTriggerTime
	a.fieldMap["trigger_time"] = a.TriggerTime
	a.fieldMap["trigger_value"] = a.TriggerValue
	a.fieldMap["recover_time"] = a.RecoverTime
	a.fieldMap["last_eval_time"] = a.LastEvalTime
	a.fieldMap["tags"] = a.Tags
	a.fieldMap["annotations"] = a.Annotations
	a.fieldMap["rule_config"] = a.RuleConfig
}

func (a alertHisEvent) clone(db *gorm.DB) alertHisEvent {
	a.alertHisEventDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a alertHisEvent) replaceDB(db *gorm.DB) alertHisEvent {
	a.alertHisEventDo.ReplaceDB(db)
	return a
}

type alertHisEventDo struct{ gen.DO }

type IAlertHisEventDo interface {
	gen.SubQuery
	Debug() IAlertHisEventDo
	WithContext(ctx context.Context) IAlertHisEventDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAlertHisEventDo
	WriteDB() IAlertHisEventDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAlertHisEventDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAlertHisEventDo
	Not(conds ...gen.Condition) IAlertHisEventDo
	Or(conds ...gen.Condition) IAlertHisEventDo
	Select(conds ...field.Expr) IAlertHisEventDo
	Where(conds ...gen.Condition) IAlertHisEventDo
	Order(conds ...field.Expr) IAlertHisEventDo
	Distinct(cols ...field.Expr) IAlertHisEventDo
	Omit(cols ...field.Expr) IAlertHisEventDo
	Join(table schema.Tabler, on ...field.Expr) IAlertHisEventDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAlertHisEventDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAlertHisEventDo
	Group(cols ...field.Expr) IAlertHisEventDo
	Having(conds ...gen.Condition) IAlertHisEventDo
	Limit(limit int) IAlertHisEventDo
	Offset(offset int) IAlertHisEventDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAlertHisEventDo
	Unscoped() IAlertHisEventDo
	Create(values ...*model.AlertHisEvent) error
	CreateInBatches(values []*model.AlertHisEvent, batchSize int) error
	Save(values ...*model.AlertHisEvent) error
	First() (*model.AlertHisEvent, error)
	Take() (*model.AlertHisEvent, error)
	Last() (*model.AlertHisEvent, error)
	Find() ([]*model.AlertHisEvent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlertHisEvent, err error)
	FindInBatches(result *[]*model.AlertHisEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AlertHisEvent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAlertHisEventDo
	Assign(attrs ...field.AssignExpr) IAlertHisEventDo
	Joins(fields ...field.RelationField) IAlertHisEventDo
	Preload(fields ...field.RelationField) IAlertHisEventDo
	FirstOrInit() (*model.AlertHisEvent, error)
	FirstOrCreate() (*model.AlertHisEvent, error)
	FindByPage(offset int, limit int) (result []*model.AlertHisEvent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAlertHisEventDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a alertHisEventDo) Debug() IAlertHisEventDo {
	return a.withDO(a.DO.Debug())
}

func (a alertHisEventDo) WithContext(ctx context.Context) IAlertHisEventDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a alertHisEventDo) ReadDB() IAlertHisEventDo {
	return a.Clauses(dbresolver.Read)
}

func (a alertHisEventDo) WriteDB() IAlertHisEventDo {
	return a.Clauses(dbresolver.Write)
}

func (a alertHisEventDo) Session(config *gorm.Session) IAlertHisEventDo {
	return a.withDO(a.DO.Session(config))
}

func (a alertHisEventDo) Clauses(conds ...clause.Expression) IAlertHisEventDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a alertHisEventDo) Returning(value interface{}, columns ...string) IAlertHisEventDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a alertHisEventDo) Not(conds ...gen.Condition) IAlertHisEventDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a alertHisEventDo) Or(conds ...gen.Condition) IAlertHisEventDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a alertHisEventDo) Select(conds ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a alertHisEventDo) Where(conds ...gen.Condition) IAlertHisEventDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a alertHisEventDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IAlertHisEventDo {
	return a.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (a alertHisEventDo) Order(conds ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a alertHisEventDo) Distinct(cols ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a alertHisEventDo) Omit(cols ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a alertHisEventDo) Join(table schema.Tabler, on ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a alertHisEventDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a alertHisEventDo) RightJoin(table schema.Tabler, on ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a alertHisEventDo) Group(cols ...field.Expr) IAlertHisEventDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a alertHisEventDo) Having(conds ...gen.Condition) IAlertHisEventDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a alertHisEventDo) Limit(limit int) IAlertHisEventDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a alertHisEventDo) Offset(offset int) IAlertHisEventDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a alertHisEventDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAlertHisEventDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a alertHisEventDo) Unscoped() IAlertHisEventDo {
	return a.withDO(a.DO.Unscoped())
}

func (a alertHisEventDo) Create(values ...*model.AlertHisEvent) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a alertHisEventDo) CreateInBatches(values []*model.AlertHisEvent, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a alertHisEventDo) Save(values ...*model.AlertHisEvent) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a alertHisEventDo) First() (*model.AlertHisEvent, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertHisEvent), nil
	}
}

func (a alertHisEventDo) Take() (*model.AlertHisEvent, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertHisEvent), nil
	}
}

func (a alertHisEventDo) Last() (*model.AlertHisEvent, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertHisEvent), nil
	}
}

func (a alertHisEventDo) Find() ([]*model.AlertHisEvent, error) {
	result, err := a.DO.Find()
	return result.([]*model.AlertHisEvent), err
}

func (a alertHisEventDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlertHisEvent, err error) {
	buf := make([]*model.AlertHisEvent, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a alertHisEventDo) FindInBatches(result *[]*model.AlertHisEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a alertHisEventDo) Attrs(attrs ...field.AssignExpr) IAlertHisEventDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a alertHisEventDo) Assign(attrs ...field.AssignExpr) IAlertHisEventDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a alertHisEventDo) Joins(fields ...field.RelationField) IAlertHisEventDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a alertHisEventDo) Preload(fields ...field.RelationField) IAlertHisEventDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a alertHisEventDo) FirstOrInit() (*model.AlertHisEvent, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertHisEvent), nil
	}
}

func (a alertHisEventDo) FirstOrCreate() (*model.AlertHisEvent, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertHisEvent), nil
	}
}

func (a alertHisEventDo) FindByPage(offset int, limit int) (result []*model.AlertHisEvent, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a alertHisEventDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a alertHisEventDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a alertHisEventDo) Delete(models ...*model.AlertHisEvent) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *alertHisEventDo) withDO(do gen.Dao) *alertHisEventDo {
	a.DO = *do.(*gen.DO)
	return a
}
