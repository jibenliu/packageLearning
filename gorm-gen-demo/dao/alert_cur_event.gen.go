// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm-gen-demo/model"
)

func newAlertCurEvent(db *gorm.DB, opts ...gen.DOOption) alertCurEvent {
	_alertCurEvent := alertCurEvent{}

	_alertCurEvent.alertCurEventDo.UseDB(db, opts...)
	_alertCurEvent.alertCurEventDo.UseModel(&model.AlertCurEvent{})

	tableName := _alertCurEvent.alertCurEventDo.TableName()
	_alertCurEvent.ALL = field.NewAsterisk(tableName)
	_alertCurEvent.ID = field.NewInt64(tableName, "id")
	_alertCurEvent.Cate = field.NewString(tableName, "cate")
	_alertCurEvent.DatasourceID = field.NewInt64(tableName, "datasource_id")
	_alertCurEvent.Cluster = field.NewString(tableName, "cluster")
	_alertCurEvent.GroupID = field.NewInt64(tableName, "group_id")
	_alertCurEvent.GroupName = field.NewString(tableName, "group_name")
	_alertCurEvent.Hash = field.NewString(tableName, "hash")
	_alertCurEvent.RuleID = field.NewInt64(tableName, "rule_id")
	_alertCurEvent.RuleName = field.NewString(tableName, "rule_name")
	_alertCurEvent.RuleNote = field.NewString(tableName, "rule_note")
	_alertCurEvent.RuleProd = field.NewString(tableName, "rule_prod")
	_alertCurEvent.RuleAlgo = field.NewString(tableName, "rule_algo")
	_alertCurEvent.Severity = field.NewInt64(tableName, "severity")
	_alertCurEvent.PromForDuration = field.NewInt64(tableName, "prom_for_duration")
	_alertCurEvent.PromQl = field.NewString(tableName, "prom_ql")
	_alertCurEvent.PromEvalInterval = field.NewInt64(tableName, "prom_eval_interval")
	_alertCurEvent.Callbacks = field.NewString(tableName, "callbacks")
	_alertCurEvent.RunbookURL = field.NewString(tableName, "runbook_url")
	_alertCurEvent.NotifyRecovered = field.NewInt64(tableName, "notify_recovered")
	_alertCurEvent.NotifyChannels = field.NewString(tableName, "notify_channels")
	_alertCurEvent.NotifyGroups = field.NewString(tableName, "notify_groups")
	_alertCurEvent.NotifyRepeatNext = field.NewInt64(tableName, "notify_repeat_next")
	_alertCurEvent.NotifyCurNumber = field.NewInt64(tableName, "notify_cur_number")
	_alertCurEvent.TargetIdent = field.NewString(tableName, "target_ident")
	_alertCurEvent.TargetNote = field.NewString(tableName, "target_note")
	_alertCurEvent.FirstTriggerTime = field.NewInt64(tableName, "first_trigger_time")
	_alertCurEvent.TriggerTime = field.NewInt64(tableName, "trigger_time")
	_alertCurEvent.TriggerValue = field.NewString(tableName, "trigger_value")
	_alertCurEvent.Annotations = field.NewString(tableName, "annotations")
	_alertCurEvent.RuleConfig = field.NewString(tableName, "rule_config")
	_alertCurEvent.Tags = field.NewString(tableName, "tags")

	_alertCurEvent.fillFieldMap()

	return _alertCurEvent
}

type alertCurEvent struct {
	alertCurEventDo

	ALL              field.Asterisk
	ID               field.Int64 // use alert_his_event.id
	Cate             field.String
	DatasourceID     field.Int64 // datasource id
	Cluster          field.String
	GroupID          field.Int64  // busi group id of rule
	GroupName        field.String // busi group name
	Hash             field.String // rule_id + vector_pk
	RuleID           field.Int64
	RuleName         field.String
	RuleNote         field.String
	RuleProd         field.String
	RuleAlgo         field.String
	Severity         field.Int64  // 0:Emergency 1:Warning 2:Notice
	PromForDuration  field.Int64  // prometheus for, unit:s
	PromQl           field.String // promql
	PromEvalInterval field.Int64  // evaluate interval
	Callbacks        field.String // split by space: http://a.com/api/x http://a.com/api/y
	RunbookURL       field.String
	NotifyRecovered  field.Int64  // whether notify when recovery
	NotifyChannels   field.String // split by space: sms voice email dingtalk wecom
	NotifyGroups     field.String // split by space: 233 43
	NotifyRepeatNext field.Int64  // next timestamp to notify, get repeat settings from rule
	NotifyCurNumber  field.Int64
	TargetIdent      field.String // target ident, also in tags
	TargetNote       field.String // target note
	FirstTriggerTime field.Int64
	TriggerTime      field.Int64
	TriggerValue     field.String
	Annotations      field.String // annotations
	RuleConfig       field.String // annotations
	Tags             field.String // merge data_tags rule_tags, split by ,,

	fieldMap map[string]field.Expr
}

func (a alertCurEvent) Table(newTableName string) *alertCurEvent {
	a.alertCurEventDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a alertCurEvent) As(alias string) *alertCurEvent {
	a.alertCurEventDo.DO = *(a.alertCurEventDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *alertCurEvent) updateTableName(table string) *alertCurEvent {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.Cate = field.NewString(table, "cate")
	a.DatasourceID = field.NewInt64(table, "datasource_id")
	a.Cluster = field.NewString(table, "cluster")
	a.GroupID = field.NewInt64(table, "group_id")
	a.GroupName = field.NewString(table, "group_name")
	a.Hash = field.NewString(table, "hash")
	a.RuleID = field.NewInt64(table, "rule_id")
	a.RuleName = field.NewString(table, "rule_name")
	a.RuleNote = field.NewString(table, "rule_note")
	a.RuleProd = field.NewString(table, "rule_prod")
	a.RuleAlgo = field.NewString(table, "rule_algo")
	a.Severity = field.NewInt64(table, "severity")
	a.PromForDuration = field.NewInt64(table, "prom_for_duration")
	a.PromQl = field.NewString(table, "prom_ql")
	a.PromEvalInterval = field.NewInt64(table, "prom_eval_interval")
	a.Callbacks = field.NewString(table, "callbacks")
	a.RunbookURL = field.NewString(table, "runbook_url")
	a.NotifyRecovered = field.NewInt64(table, "notify_recovered")
	a.NotifyChannels = field.NewString(table, "notify_channels")
	a.NotifyGroups = field.NewString(table, "notify_groups")
	a.NotifyRepeatNext = field.NewInt64(table, "notify_repeat_next")
	a.NotifyCurNumber = field.NewInt64(table, "notify_cur_number")
	a.TargetIdent = field.NewString(table, "target_ident")
	a.TargetNote = field.NewString(table, "target_note")
	a.FirstTriggerTime = field.NewInt64(table, "first_trigger_time")
	a.TriggerTime = field.NewInt64(table, "trigger_time")
	a.TriggerValue = field.NewString(table, "trigger_value")
	a.Annotations = field.NewString(table, "annotations")
	a.RuleConfig = field.NewString(table, "rule_config")
	a.Tags = field.NewString(table, "tags")

	a.fillFieldMap()

	return a
}

func (a *alertCurEvent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *alertCurEvent) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 31)
	a.fieldMap["id"] = a.ID
	a.fieldMap["cate"] = a.Cate
	a.fieldMap["datasource_id"] = a.DatasourceID
	a.fieldMap["cluster"] = a.Cluster
	a.fieldMap["group_id"] = a.GroupID
	a.fieldMap["group_name"] = a.GroupName
	a.fieldMap["hash"] = a.Hash
	a.fieldMap["rule_id"] = a.RuleID
	a.fieldMap["rule_name"] = a.RuleName
	a.fieldMap["rule_note"] = a.RuleNote
	a.fieldMap["rule_prod"] = a.RuleProd
	a.fieldMap["rule_algo"] = a.RuleAlgo
	a.fieldMap["severity"] = a.Severity
	a.fieldMap["prom_for_duration"] = a.PromForDuration
	a.fieldMap["prom_ql"] = a.PromQl
	a.fieldMap["prom_eval_interval"] = a.PromEvalInterval
	a.fieldMap["callbacks"] = a.Callbacks
	a.fieldMap["runbook_url"] = a.RunbookURL
	a.fieldMap["notify_recovered"] = a.NotifyRecovered
	a.fieldMap["notify_channels"] = a.NotifyChannels
	a.fieldMap["notify_groups"] = a.NotifyGroups
	a.fieldMap["notify_repeat_next"] = a.NotifyRepeatNext
	a.fieldMap["notify_cur_number"] = a.NotifyCurNumber
	a.fieldMap["target_ident"] = a.TargetIdent
	a.fieldMap["target_note"] = a.TargetNote
	a.fieldMap["first_trigger_time"] = a.FirstTriggerTime
	a.fieldMap["trigger_time"] = a.TriggerTime
	a.fieldMap["trigger_value"] = a.TriggerValue
	a.fieldMap["annotations"] = a.Annotations
	a.fieldMap["rule_config"] = a.RuleConfig
	a.fieldMap["tags"] = a.Tags
}

func (a alertCurEvent) clone(db *gorm.DB) alertCurEvent {
	a.alertCurEventDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a alertCurEvent) replaceDB(db *gorm.DB) alertCurEvent {
	a.alertCurEventDo.ReplaceDB(db)
	return a
}

type alertCurEventDo struct{ gen.DO }

type IAlertCurEventDo interface {
	gen.SubQuery
	Debug() IAlertCurEventDo
	WithContext(ctx context.Context) IAlertCurEventDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAlertCurEventDo
	WriteDB() IAlertCurEventDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAlertCurEventDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAlertCurEventDo
	Not(conds ...gen.Condition) IAlertCurEventDo
	Or(conds ...gen.Condition) IAlertCurEventDo
	Select(conds ...field.Expr) IAlertCurEventDo
	Where(conds ...gen.Condition) IAlertCurEventDo
	Order(conds ...field.Expr) IAlertCurEventDo
	Distinct(cols ...field.Expr) IAlertCurEventDo
	Omit(cols ...field.Expr) IAlertCurEventDo
	Join(table schema.Tabler, on ...field.Expr) IAlertCurEventDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAlertCurEventDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAlertCurEventDo
	Group(cols ...field.Expr) IAlertCurEventDo
	Having(conds ...gen.Condition) IAlertCurEventDo
	Limit(limit int) IAlertCurEventDo
	Offset(offset int) IAlertCurEventDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAlertCurEventDo
	Unscoped() IAlertCurEventDo
	Create(values ...*model.AlertCurEvent) error
	CreateInBatches(values []*model.AlertCurEvent, batchSize int) error
	Save(values ...*model.AlertCurEvent) error
	First() (*model.AlertCurEvent, error)
	Take() (*model.AlertCurEvent, error)
	Last() (*model.AlertCurEvent, error)
	Find() ([]*model.AlertCurEvent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlertCurEvent, err error)
	FindInBatches(result *[]*model.AlertCurEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AlertCurEvent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAlertCurEventDo
	Assign(attrs ...field.AssignExpr) IAlertCurEventDo
	Joins(fields ...field.RelationField) IAlertCurEventDo
	Preload(fields ...field.RelationField) IAlertCurEventDo
	FirstOrInit() (*model.AlertCurEvent, error)
	FirstOrCreate() (*model.AlertCurEvent, error)
	FindByPage(offset int, limit int) (result []*model.AlertCurEvent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAlertCurEventDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a alertCurEventDo) Debug() IAlertCurEventDo {
	return a.withDO(a.DO.Debug())
}

func (a alertCurEventDo) WithContext(ctx context.Context) IAlertCurEventDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a alertCurEventDo) ReadDB() IAlertCurEventDo {
	return a.Clauses(dbresolver.Read)
}

func (a alertCurEventDo) WriteDB() IAlertCurEventDo {
	return a.Clauses(dbresolver.Write)
}

func (a alertCurEventDo) Session(config *gorm.Session) IAlertCurEventDo {
	return a.withDO(a.DO.Session(config))
}

func (a alertCurEventDo) Clauses(conds ...clause.Expression) IAlertCurEventDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a alertCurEventDo) Returning(value interface{}, columns ...string) IAlertCurEventDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a alertCurEventDo) Not(conds ...gen.Condition) IAlertCurEventDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a alertCurEventDo) Or(conds ...gen.Condition) IAlertCurEventDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a alertCurEventDo) Select(conds ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a alertCurEventDo) Where(conds ...gen.Condition) IAlertCurEventDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a alertCurEventDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IAlertCurEventDo {
	return a.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (a alertCurEventDo) Order(conds ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a alertCurEventDo) Distinct(cols ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a alertCurEventDo) Omit(cols ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a alertCurEventDo) Join(table schema.Tabler, on ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a alertCurEventDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a alertCurEventDo) RightJoin(table schema.Tabler, on ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a alertCurEventDo) Group(cols ...field.Expr) IAlertCurEventDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a alertCurEventDo) Having(conds ...gen.Condition) IAlertCurEventDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a alertCurEventDo) Limit(limit int) IAlertCurEventDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a alertCurEventDo) Offset(offset int) IAlertCurEventDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a alertCurEventDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAlertCurEventDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a alertCurEventDo) Unscoped() IAlertCurEventDo {
	return a.withDO(a.DO.Unscoped())
}

func (a alertCurEventDo) Create(values ...*model.AlertCurEvent) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a alertCurEventDo) CreateInBatches(values []*model.AlertCurEvent, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a alertCurEventDo) Save(values ...*model.AlertCurEvent) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a alertCurEventDo) First() (*model.AlertCurEvent, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertCurEvent), nil
	}
}

func (a alertCurEventDo) Take() (*model.AlertCurEvent, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertCurEvent), nil
	}
}

func (a alertCurEventDo) Last() (*model.AlertCurEvent, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertCurEvent), nil
	}
}

func (a alertCurEventDo) Find() ([]*model.AlertCurEvent, error) {
	result, err := a.DO.Find()
	return result.([]*model.AlertCurEvent), err
}

func (a alertCurEventDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlertCurEvent, err error) {
	buf := make([]*model.AlertCurEvent, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a alertCurEventDo) FindInBatches(result *[]*model.AlertCurEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a alertCurEventDo) Attrs(attrs ...field.AssignExpr) IAlertCurEventDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a alertCurEventDo) Assign(attrs ...field.AssignExpr) IAlertCurEventDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a alertCurEventDo) Joins(fields ...field.RelationField) IAlertCurEventDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a alertCurEventDo) Preload(fields ...field.RelationField) IAlertCurEventDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a alertCurEventDo) FirstOrInit() (*model.AlertCurEvent, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertCurEvent), nil
	}
}

func (a alertCurEventDo) FirstOrCreate() (*model.AlertCurEvent, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertCurEvent), nil
	}
}

func (a alertCurEventDo) FindByPage(offset int, limit int) (result []*model.AlertCurEvent, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a alertCurEventDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a alertCurEventDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a alertCurEventDo) Delete(models ...*model.AlertCurEvent) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *alertCurEventDo) withDO(do gen.Dao) *alertCurEventDo {
	a.DO = *do.(*gen.DO)
	return a
}
