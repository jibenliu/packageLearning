// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm-gen-demo/model"
)

func newTaskTpl(db *gorm.DB, opts ...gen.DOOption) taskTpl {
	_taskTpl := taskTpl{}

	_taskTpl.taskTplDo.UseDB(db, opts...)
	_taskTpl.taskTplDo.UseModel(&model.TaskTpl{})

	tableName := _taskTpl.taskTplDo.TableName()
	_taskTpl.ALL = field.NewAsterisk(tableName)
	_taskTpl.ID = field.NewInt64(tableName, "id")
	_taskTpl.GroupID = field.NewInt64(tableName, "group_id")
	_taskTpl.Title = field.NewString(tableName, "title")
	_taskTpl.Account = field.NewString(tableName, "account")
	_taskTpl.Batch = field.NewInt64(tableName, "batch")
	_taskTpl.Tolerance = field.NewInt64(tableName, "tolerance")
	_taskTpl.Timeout = field.NewInt64(tableName, "timeout")
	_taskTpl.Pause = field.NewString(tableName, "pause")
	_taskTpl.Script = field.NewString(tableName, "script")
	_taskTpl.Args = field.NewString(tableName, "args")
	_taskTpl.Tags = field.NewString(tableName, "tags")
	_taskTpl.CreateAt = field.NewInt64(tableName, "create_at")
	_taskTpl.CreateBy = field.NewString(tableName, "create_by")
	_taskTpl.UpdateAt = field.NewInt64(tableName, "update_at")
	_taskTpl.UpdateBy = field.NewString(tableName, "update_by")

	_taskTpl.fillFieldMap()

	return _taskTpl
}

type taskTpl struct {
	taskTplDo

	ALL       field.Asterisk
	ID        field.Int64
	GroupID   field.Int64 // busi group id
	Title     field.String
	Account   field.String
	Batch     field.Int64
	Tolerance field.Int64
	Timeout   field.Int64
	Pause     field.String
	Script    field.String
	Args      field.String
	Tags      field.String // split by space
	CreateAt  field.Int64
	CreateBy  field.String
	UpdateAt  field.Int64
	UpdateBy  field.String

	fieldMap map[string]field.Expr
}

func (t taskTpl) Table(newTableName string) *taskTpl {
	t.taskTplDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t taskTpl) As(alias string) *taskTpl {
	t.taskTplDo.DO = *(t.taskTplDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *taskTpl) updateTableName(table string) *taskTpl {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.GroupID = field.NewInt64(table, "group_id")
	t.Title = field.NewString(table, "title")
	t.Account = field.NewString(table, "account")
	t.Batch = field.NewInt64(table, "batch")
	t.Tolerance = field.NewInt64(table, "tolerance")
	t.Timeout = field.NewInt64(table, "timeout")
	t.Pause = field.NewString(table, "pause")
	t.Script = field.NewString(table, "script")
	t.Args = field.NewString(table, "args")
	t.Tags = field.NewString(table, "tags")
	t.CreateAt = field.NewInt64(table, "create_at")
	t.CreateBy = field.NewString(table, "create_by")
	t.UpdateAt = field.NewInt64(table, "update_at")
	t.UpdateBy = field.NewString(table, "update_by")

	t.fillFieldMap()

	return t
}

func (t *taskTpl) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *taskTpl) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 15)
	t.fieldMap["id"] = t.ID
	t.fieldMap["group_id"] = t.GroupID
	t.fieldMap["title"] = t.Title
	t.fieldMap["account"] = t.Account
	t.fieldMap["batch"] = t.Batch
	t.fieldMap["tolerance"] = t.Tolerance
	t.fieldMap["timeout"] = t.Timeout
	t.fieldMap["pause"] = t.Pause
	t.fieldMap["script"] = t.Script
	t.fieldMap["args"] = t.Args
	t.fieldMap["tags"] = t.Tags
	t.fieldMap["create_at"] = t.CreateAt
	t.fieldMap["create_by"] = t.CreateBy
	t.fieldMap["update_at"] = t.UpdateAt
	t.fieldMap["update_by"] = t.UpdateBy
}

func (t taskTpl) clone(db *gorm.DB) taskTpl {
	t.taskTplDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t taskTpl) replaceDB(db *gorm.DB) taskTpl {
	t.taskTplDo.ReplaceDB(db)
	return t
}

type taskTplDo struct{ gen.DO }

type ITaskTplDo interface {
	gen.SubQuery
	Debug() ITaskTplDo
	WithContext(ctx context.Context) ITaskTplDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITaskTplDo
	WriteDB() ITaskTplDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITaskTplDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITaskTplDo
	Not(conds ...gen.Condition) ITaskTplDo
	Or(conds ...gen.Condition) ITaskTplDo
	Select(conds ...field.Expr) ITaskTplDo
	Where(conds ...gen.Condition) ITaskTplDo
	Order(conds ...field.Expr) ITaskTplDo
	Distinct(cols ...field.Expr) ITaskTplDo
	Omit(cols ...field.Expr) ITaskTplDo
	Join(table schema.Tabler, on ...field.Expr) ITaskTplDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITaskTplDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITaskTplDo
	Group(cols ...field.Expr) ITaskTplDo
	Having(conds ...gen.Condition) ITaskTplDo
	Limit(limit int) ITaskTplDo
	Offset(offset int) ITaskTplDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITaskTplDo
	Unscoped() ITaskTplDo
	Create(values ...*model.TaskTpl) error
	CreateInBatches(values []*model.TaskTpl, batchSize int) error
	Save(values ...*model.TaskTpl) error
	First() (*model.TaskTpl, error)
	Take() (*model.TaskTpl, error)
	Last() (*model.TaskTpl, error)
	Find() ([]*model.TaskTpl, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TaskTpl, err error)
	FindInBatches(result *[]*model.TaskTpl, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TaskTpl) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITaskTplDo
	Assign(attrs ...field.AssignExpr) ITaskTplDo
	Joins(fields ...field.RelationField) ITaskTplDo
	Preload(fields ...field.RelationField) ITaskTplDo
	FirstOrInit() (*model.TaskTpl, error)
	FirstOrCreate() (*model.TaskTpl, error)
	FindByPage(offset int, limit int) (result []*model.TaskTpl, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITaskTplDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t taskTplDo) Debug() ITaskTplDo {
	return t.withDO(t.DO.Debug())
}

func (t taskTplDo) WithContext(ctx context.Context) ITaskTplDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t taskTplDo) ReadDB() ITaskTplDo {
	return t.Clauses(dbresolver.Read)
}

func (t taskTplDo) WriteDB() ITaskTplDo {
	return t.Clauses(dbresolver.Write)
}

func (t taskTplDo) Session(config *gorm.Session) ITaskTplDo {
	return t.withDO(t.DO.Session(config))
}

func (t taskTplDo) Clauses(conds ...clause.Expression) ITaskTplDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t taskTplDo) Returning(value interface{}, columns ...string) ITaskTplDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t taskTplDo) Not(conds ...gen.Condition) ITaskTplDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t taskTplDo) Or(conds ...gen.Condition) ITaskTplDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t taskTplDo) Select(conds ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t taskTplDo) Where(conds ...gen.Condition) ITaskTplDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t taskTplDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITaskTplDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t taskTplDo) Order(conds ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t taskTplDo) Distinct(cols ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t taskTplDo) Omit(cols ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t taskTplDo) Join(table schema.Tabler, on ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t taskTplDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t taskTplDo) RightJoin(table schema.Tabler, on ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t taskTplDo) Group(cols ...field.Expr) ITaskTplDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t taskTplDo) Having(conds ...gen.Condition) ITaskTplDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t taskTplDo) Limit(limit int) ITaskTplDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t taskTplDo) Offset(offset int) ITaskTplDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t taskTplDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITaskTplDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t taskTplDo) Unscoped() ITaskTplDo {
	return t.withDO(t.DO.Unscoped())
}

func (t taskTplDo) Create(values ...*model.TaskTpl) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t taskTplDo) CreateInBatches(values []*model.TaskTpl, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t taskTplDo) Save(values ...*model.TaskTpl) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t taskTplDo) First() (*model.TaskTpl, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskTpl), nil
	}
}

func (t taskTplDo) Take() (*model.TaskTpl, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskTpl), nil
	}
}

func (t taskTplDo) Last() (*model.TaskTpl, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskTpl), nil
	}
}

func (t taskTplDo) Find() ([]*model.TaskTpl, error) {
	result, err := t.DO.Find()
	return result.([]*model.TaskTpl), err
}

func (t taskTplDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TaskTpl, err error) {
	buf := make([]*model.TaskTpl, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t taskTplDo) FindInBatches(result *[]*model.TaskTpl, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t taskTplDo) Attrs(attrs ...field.AssignExpr) ITaskTplDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t taskTplDo) Assign(attrs ...field.AssignExpr) ITaskTplDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t taskTplDo) Joins(fields ...field.RelationField) ITaskTplDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t taskTplDo) Preload(fields ...field.RelationField) ITaskTplDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t taskTplDo) FirstOrInit() (*model.TaskTpl, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskTpl), nil
	}
}

func (t taskTplDo) FirstOrCreate() (*model.TaskTpl, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskTpl), nil
	}
}

func (t taskTplDo) FindByPage(offset int, limit int) (result []*model.TaskTpl, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t taskTplDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t taskTplDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t taskTplDo) Delete(models ...*model.TaskTpl) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *taskTplDo) withDO(do gen.Dao) *taskTplDo {
	t.DO = *do.(*gen.DO)
	return t
}
