// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm-gen-demo/model"
)

func newTarget(db *gorm.DB, opts ...gen.DOOption) target {
	_target := target{}

	_target.targetDo.UseDB(db, opts...)
	_target.targetDo.UseModel(&model.Target{})

	tableName := _target.targetDo.TableName()
	_target.ALL = field.NewAsterisk(tableName)
	_target.ID = field.NewInt64(tableName, "id")
	_target.GroupID = field.NewInt64(tableName, "group_id")
	_target.Ident = field.NewString(tableName, "ident")
	_target.Note = field.NewString(tableName, "note")
	_target.Tags = field.NewString(tableName, "tags")
	_target.UpdateAt = field.NewInt64(tableName, "update_at")

	_target.fillFieldMap()

	return _target
}

type target struct {
	targetDo

	ALL      field.Asterisk
	ID       field.Int64
	GroupID  field.Int64  // busi group id
	Ident    field.String // target id
	Note     field.String // append to alert event as field
	Tags     field.String // append to series data as tags, split by space, append external space at suffix
	UpdateAt field.Int64

	fieldMap map[string]field.Expr
}

func (t target) Table(newTableName string) *target {
	t.targetDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t target) As(alias string) *target {
	t.targetDo.DO = *(t.targetDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *target) updateTableName(table string) *target {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.GroupID = field.NewInt64(table, "group_id")
	t.Ident = field.NewString(table, "ident")
	t.Note = field.NewString(table, "note")
	t.Tags = field.NewString(table, "tags")
	t.UpdateAt = field.NewInt64(table, "update_at")

	t.fillFieldMap()

	return t
}

func (t *target) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *target) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 6)
	t.fieldMap["id"] = t.ID
	t.fieldMap["group_id"] = t.GroupID
	t.fieldMap["ident"] = t.Ident
	t.fieldMap["note"] = t.Note
	t.fieldMap["tags"] = t.Tags
	t.fieldMap["update_at"] = t.UpdateAt
}

func (t target) clone(db *gorm.DB) target {
	t.targetDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t target) replaceDB(db *gorm.DB) target {
	t.targetDo.ReplaceDB(db)
	return t
}

type targetDo struct{ gen.DO }

type ITargetDo interface {
	gen.SubQuery
	Debug() ITargetDo
	WithContext(ctx context.Context) ITargetDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITargetDo
	WriteDB() ITargetDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITargetDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITargetDo
	Not(conds ...gen.Condition) ITargetDo
	Or(conds ...gen.Condition) ITargetDo
	Select(conds ...field.Expr) ITargetDo
	Where(conds ...gen.Condition) ITargetDo
	Order(conds ...field.Expr) ITargetDo
	Distinct(cols ...field.Expr) ITargetDo
	Omit(cols ...field.Expr) ITargetDo
	Join(table schema.Tabler, on ...field.Expr) ITargetDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITargetDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITargetDo
	Group(cols ...field.Expr) ITargetDo
	Having(conds ...gen.Condition) ITargetDo
	Limit(limit int) ITargetDo
	Offset(offset int) ITargetDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITargetDo
	Unscoped() ITargetDo
	Create(values ...*model.Target) error
	CreateInBatches(values []*model.Target, batchSize int) error
	Save(values ...*model.Target) error
	First() (*model.Target, error)
	Take() (*model.Target, error)
	Last() (*model.Target, error)
	Find() ([]*model.Target, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Target, err error)
	FindInBatches(result *[]*model.Target, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Target) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITargetDo
	Assign(attrs ...field.AssignExpr) ITargetDo
	Joins(fields ...field.RelationField) ITargetDo
	Preload(fields ...field.RelationField) ITargetDo
	FirstOrInit() (*model.Target, error)
	FirstOrCreate() (*model.Target, error)
	FindByPage(offset int, limit int) (result []*model.Target, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITargetDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t targetDo) Debug() ITargetDo {
	return t.withDO(t.DO.Debug())
}

func (t targetDo) WithContext(ctx context.Context) ITargetDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t targetDo) ReadDB() ITargetDo {
	return t.Clauses(dbresolver.Read)
}

func (t targetDo) WriteDB() ITargetDo {
	return t.Clauses(dbresolver.Write)
}

func (t targetDo) Session(config *gorm.Session) ITargetDo {
	return t.withDO(t.DO.Session(config))
}

func (t targetDo) Clauses(conds ...clause.Expression) ITargetDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t targetDo) Returning(value interface{}, columns ...string) ITargetDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t targetDo) Not(conds ...gen.Condition) ITargetDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t targetDo) Or(conds ...gen.Condition) ITargetDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t targetDo) Select(conds ...field.Expr) ITargetDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t targetDo) Where(conds ...gen.Condition) ITargetDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t targetDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITargetDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t targetDo) Order(conds ...field.Expr) ITargetDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t targetDo) Distinct(cols ...field.Expr) ITargetDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t targetDo) Omit(cols ...field.Expr) ITargetDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t targetDo) Join(table schema.Tabler, on ...field.Expr) ITargetDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t targetDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITargetDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t targetDo) RightJoin(table schema.Tabler, on ...field.Expr) ITargetDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t targetDo) Group(cols ...field.Expr) ITargetDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t targetDo) Having(conds ...gen.Condition) ITargetDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t targetDo) Limit(limit int) ITargetDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t targetDo) Offset(offset int) ITargetDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t targetDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITargetDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t targetDo) Unscoped() ITargetDo {
	return t.withDO(t.DO.Unscoped())
}

func (t targetDo) Create(values ...*model.Target) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t targetDo) CreateInBatches(values []*model.Target, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t targetDo) Save(values ...*model.Target) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t targetDo) First() (*model.Target, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Target), nil
	}
}

func (t targetDo) Take() (*model.Target, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Target), nil
	}
}

func (t targetDo) Last() (*model.Target, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Target), nil
	}
}

func (t targetDo) Find() ([]*model.Target, error) {
	result, err := t.DO.Find()
	return result.([]*model.Target), err
}

func (t targetDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Target, err error) {
	buf := make([]*model.Target, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t targetDo) FindInBatches(result *[]*model.Target, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t targetDo) Attrs(attrs ...field.AssignExpr) ITargetDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t targetDo) Assign(attrs ...field.AssignExpr) ITargetDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t targetDo) Joins(fields ...field.RelationField) ITargetDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t targetDo) Preload(fields ...field.RelationField) ITargetDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t targetDo) FirstOrInit() (*model.Target, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Target), nil
	}
}

func (t targetDo) FirstOrCreate() (*model.Target, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Target), nil
	}
}

func (t targetDo) FindByPage(offset int, limit int) (result []*model.Target, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t targetDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t targetDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t targetDo) Delete(models ...*model.Target) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *targetDo) withDO(do gen.Dao) *targetDo {
	t.DO = *do.(*gen.DO)
	return t
}
