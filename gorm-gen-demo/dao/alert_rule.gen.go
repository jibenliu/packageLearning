// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm-gen-demo/model"
)

func newAlertRule(db *gorm.DB, opts ...gen.DOOption) alertRule {
	_alertRule := alertRule{}

	_alertRule.alertRuleDo.UseDB(db, opts...)
	_alertRule.alertRuleDo.UseModel(&model.AlertRule{})

	tableName := _alertRule.alertRuleDo.TableName()
	_alertRule.ALL = field.NewAsterisk(tableName)
	_alertRule.ID = field.NewInt64(tableName, "id")
	_alertRule.GroupID = field.NewInt64(tableName, "group_id")
	_alertRule.Cate = field.NewString(tableName, "cate")
	_alertRule.DatasourceIds = field.NewString(tableName, "datasource_ids")
	_alertRule.Cluster = field.NewString(tableName, "cluster")
	_alertRule.Name = field.NewString(tableName, "name")
	_alertRule.Note = field.NewString(tableName, "note")
	_alertRule.Prod = field.NewString(tableName, "prod")
	_alertRule.Algorithm = field.NewString(tableName, "algorithm")
	_alertRule.AlgoParams = field.NewString(tableName, "algo_params")
	_alertRule.Delay = field.NewInt64(tableName, "delay")
	_alertRule.Severity = field.NewInt64(tableName, "severity")
	_alertRule.Disabled = field.NewInt64(tableName, "disabled")
	_alertRule.PromForDuration = field.NewInt64(tableName, "prom_for_duration")
	_alertRule.RuleConfig = field.NewString(tableName, "rule_config")
	_alertRule.PromQl = field.NewString(tableName, "prom_ql")
	_alertRule.PromEvalInterval = field.NewInt64(tableName, "prom_eval_interval")
	_alertRule.EnableStime = field.NewString(tableName, "enable_stime")
	_alertRule.EnableEtime = field.NewString(tableName, "enable_etime")
	_alertRule.EnableDaysOfWeek = field.NewString(tableName, "enable_days_of_week")
	_alertRule.EnableInBg = field.NewInt64(tableName, "enable_in_bg")
	_alertRule.NotifyRecovered = field.NewInt64(tableName, "notify_recovered")
	_alertRule.NotifyChannels = field.NewString(tableName, "notify_channels")
	_alertRule.NotifyGroups = field.NewString(tableName, "notify_groups")
	_alertRule.NotifyRepeatStep = field.NewInt64(tableName, "notify_repeat_step")
	_alertRule.NotifyMaxNumber = field.NewInt64(tableName, "notify_max_number")
	_alertRule.RecoverDuration = field.NewInt64(tableName, "recover_duration")
	_alertRule.Callbacks = field.NewString(tableName, "callbacks")
	_alertRule.RunbookURL = field.NewString(tableName, "runbook_url")
	_alertRule.AppendTags = field.NewString(tableName, "append_tags")
	_alertRule.Annotations = field.NewString(tableName, "annotations")
	_alertRule.CreateAt = field.NewInt64(tableName, "create_at")
	_alertRule.CreateBy = field.NewString(tableName, "create_by")
	_alertRule.UpdateAt = field.NewInt64(tableName, "update_at")
	_alertRule.UpdateBy = field.NewString(tableName, "update_by")

	_alertRule.fillFieldMap()

	return _alertRule
}

type alertRule struct {
	alertRuleDo

	ALL              field.Asterisk
	ID               field.Int64
	GroupID          field.Int64 // busi group id
	Cate             field.String
	DatasourceIds    field.String // datasource ids
	Cluster          field.String
	Name             field.String
	Note             field.String
	Prod             field.String
	Algorithm        field.String
	AlgoParams       field.String
	Delay            field.Int64
	Severity         field.Int64  // 1:Emergency 2:Warning 3:Notice
	Disabled         field.Int64  // 0:enabled 1:disabled
	PromForDuration  field.Int64  // prometheus for, unit:s
	RuleConfig       field.String // rule_config
	PromQl           field.String // promql
	PromEvalInterval field.Int64  // evaluate interval
	EnableStime      field.String
	EnableEtime      field.String
	EnableDaysOfWeek field.String // split by space: 0 1 2 3 4 5 6
	EnableInBg       field.Int64  // 1: only this bg 0: global
	NotifyRecovered  field.Int64  // whether notify when recovery
	NotifyChannels   field.String // split by space: sms voice email dingtalk wecom
	NotifyGroups     field.String // split by space: 233 43
	NotifyRepeatStep field.Int64  // unit: min
	NotifyMaxNumber  field.Int64
	RecoverDuration  field.Int64  // unit: s
	Callbacks        field.String // split by space: http://a.com/api/x http://a.com/api/y
	RunbookURL       field.String
	AppendTags       field.String // split by space: service=n9e mod=api
	Annotations      field.String // annotations
	CreateAt         field.Int64
	CreateBy         field.String
	UpdateAt         field.Int64
	UpdateBy         field.String

	fieldMap map[string]field.Expr
}

func (a alertRule) Table(newTableName string) *alertRule {
	a.alertRuleDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a alertRule) As(alias string) *alertRule {
	a.alertRuleDo.DO = *(a.alertRuleDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *alertRule) updateTableName(table string) *alertRule {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.GroupID = field.NewInt64(table, "group_id")
	a.Cate = field.NewString(table, "cate")
	a.DatasourceIds = field.NewString(table, "datasource_ids")
	a.Cluster = field.NewString(table, "cluster")
	a.Name = field.NewString(table, "name")
	a.Note = field.NewString(table, "note")
	a.Prod = field.NewString(table, "prod")
	a.Algorithm = field.NewString(table, "algorithm")
	a.AlgoParams = field.NewString(table, "algo_params")
	a.Delay = field.NewInt64(table, "delay")
	a.Severity = field.NewInt64(table, "severity")
	a.Disabled = field.NewInt64(table, "disabled")
	a.PromForDuration = field.NewInt64(table, "prom_for_duration")
	a.RuleConfig = field.NewString(table, "rule_config")
	a.PromQl = field.NewString(table, "prom_ql")
	a.PromEvalInterval = field.NewInt64(table, "prom_eval_interval")
	a.EnableStime = field.NewString(table, "enable_stime")
	a.EnableEtime = field.NewString(table, "enable_etime")
	a.EnableDaysOfWeek = field.NewString(table, "enable_days_of_week")
	a.EnableInBg = field.NewInt64(table, "enable_in_bg")
	a.NotifyRecovered = field.NewInt64(table, "notify_recovered")
	a.NotifyChannels = field.NewString(table, "notify_channels")
	a.NotifyGroups = field.NewString(table, "notify_groups")
	a.NotifyRepeatStep = field.NewInt64(table, "notify_repeat_step")
	a.NotifyMaxNumber = field.NewInt64(table, "notify_max_number")
	a.RecoverDuration = field.NewInt64(table, "recover_duration")
	a.Callbacks = field.NewString(table, "callbacks")
	a.RunbookURL = field.NewString(table, "runbook_url")
	a.AppendTags = field.NewString(table, "append_tags")
	a.Annotations = field.NewString(table, "annotations")
	a.CreateAt = field.NewInt64(table, "create_at")
	a.CreateBy = field.NewString(table, "create_by")
	a.UpdateAt = field.NewInt64(table, "update_at")
	a.UpdateBy = field.NewString(table, "update_by")

	a.fillFieldMap()

	return a
}

func (a *alertRule) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *alertRule) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 35)
	a.fieldMap["id"] = a.ID
	a.fieldMap["group_id"] = a.GroupID
	a.fieldMap["cate"] = a.Cate
	a.fieldMap["datasource_ids"] = a.DatasourceIds
	a.fieldMap["cluster"] = a.Cluster
	a.fieldMap["name"] = a.Name
	a.fieldMap["note"] = a.Note
	a.fieldMap["prod"] = a.Prod
	a.fieldMap["algorithm"] = a.Algorithm
	a.fieldMap["algo_params"] = a.AlgoParams
	a.fieldMap["delay"] = a.Delay
	a.fieldMap["severity"] = a.Severity
	a.fieldMap["disabled"] = a.Disabled
	a.fieldMap["prom_for_duration"] = a.PromForDuration
	a.fieldMap["rule_config"] = a.RuleConfig
	a.fieldMap["prom_ql"] = a.PromQl
	a.fieldMap["prom_eval_interval"] = a.PromEvalInterval
	a.fieldMap["enable_stime"] = a.EnableStime
	a.fieldMap["enable_etime"] = a.EnableEtime
	a.fieldMap["enable_days_of_week"] = a.EnableDaysOfWeek
	a.fieldMap["enable_in_bg"] = a.EnableInBg
	a.fieldMap["notify_recovered"] = a.NotifyRecovered
	a.fieldMap["notify_channels"] = a.NotifyChannels
	a.fieldMap["notify_groups"] = a.NotifyGroups
	a.fieldMap["notify_repeat_step"] = a.NotifyRepeatStep
	a.fieldMap["notify_max_number"] = a.NotifyMaxNumber
	a.fieldMap["recover_duration"] = a.RecoverDuration
	a.fieldMap["callbacks"] = a.Callbacks
	a.fieldMap["runbook_url"] = a.RunbookURL
	a.fieldMap["append_tags"] = a.AppendTags
	a.fieldMap["annotations"] = a.Annotations
	a.fieldMap["create_at"] = a.CreateAt
	a.fieldMap["create_by"] = a.CreateBy
	a.fieldMap["update_at"] = a.UpdateAt
	a.fieldMap["update_by"] = a.UpdateBy
}

func (a alertRule) clone(db *gorm.DB) alertRule {
	a.alertRuleDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a alertRule) replaceDB(db *gorm.DB) alertRule {
	a.alertRuleDo.ReplaceDB(db)
	return a
}

type alertRuleDo struct{ gen.DO }

type IAlertRuleDo interface {
	gen.SubQuery
	Debug() IAlertRuleDo
	WithContext(ctx context.Context) IAlertRuleDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAlertRuleDo
	WriteDB() IAlertRuleDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAlertRuleDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAlertRuleDo
	Not(conds ...gen.Condition) IAlertRuleDo
	Or(conds ...gen.Condition) IAlertRuleDo
	Select(conds ...field.Expr) IAlertRuleDo
	Where(conds ...gen.Condition) IAlertRuleDo
	Order(conds ...field.Expr) IAlertRuleDo
	Distinct(cols ...field.Expr) IAlertRuleDo
	Omit(cols ...field.Expr) IAlertRuleDo
	Join(table schema.Tabler, on ...field.Expr) IAlertRuleDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAlertRuleDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAlertRuleDo
	Group(cols ...field.Expr) IAlertRuleDo
	Having(conds ...gen.Condition) IAlertRuleDo
	Limit(limit int) IAlertRuleDo
	Offset(offset int) IAlertRuleDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAlertRuleDo
	Unscoped() IAlertRuleDo
	Create(values ...*model.AlertRule) error
	CreateInBatches(values []*model.AlertRule, batchSize int) error
	Save(values ...*model.AlertRule) error
	First() (*model.AlertRule, error)
	Take() (*model.AlertRule, error)
	Last() (*model.AlertRule, error)
	Find() ([]*model.AlertRule, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlertRule, err error)
	FindInBatches(result *[]*model.AlertRule, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AlertRule) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAlertRuleDo
	Assign(attrs ...field.AssignExpr) IAlertRuleDo
	Joins(fields ...field.RelationField) IAlertRuleDo
	Preload(fields ...field.RelationField) IAlertRuleDo
	FirstOrInit() (*model.AlertRule, error)
	FirstOrCreate() (*model.AlertRule, error)
	FindByPage(offset int, limit int) (result []*model.AlertRule, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAlertRuleDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a alertRuleDo) Debug() IAlertRuleDo {
	return a.withDO(a.DO.Debug())
}

func (a alertRuleDo) WithContext(ctx context.Context) IAlertRuleDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a alertRuleDo) ReadDB() IAlertRuleDo {
	return a.Clauses(dbresolver.Read)
}

func (a alertRuleDo) WriteDB() IAlertRuleDo {
	return a.Clauses(dbresolver.Write)
}

func (a alertRuleDo) Session(config *gorm.Session) IAlertRuleDo {
	return a.withDO(a.DO.Session(config))
}

func (a alertRuleDo) Clauses(conds ...clause.Expression) IAlertRuleDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a alertRuleDo) Returning(value interface{}, columns ...string) IAlertRuleDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a alertRuleDo) Not(conds ...gen.Condition) IAlertRuleDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a alertRuleDo) Or(conds ...gen.Condition) IAlertRuleDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a alertRuleDo) Select(conds ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a alertRuleDo) Where(conds ...gen.Condition) IAlertRuleDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a alertRuleDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IAlertRuleDo {
	return a.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (a alertRuleDo) Order(conds ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a alertRuleDo) Distinct(cols ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a alertRuleDo) Omit(cols ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a alertRuleDo) Join(table schema.Tabler, on ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a alertRuleDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a alertRuleDo) RightJoin(table schema.Tabler, on ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a alertRuleDo) Group(cols ...field.Expr) IAlertRuleDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a alertRuleDo) Having(conds ...gen.Condition) IAlertRuleDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a alertRuleDo) Limit(limit int) IAlertRuleDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a alertRuleDo) Offset(offset int) IAlertRuleDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a alertRuleDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAlertRuleDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a alertRuleDo) Unscoped() IAlertRuleDo {
	return a.withDO(a.DO.Unscoped())
}

func (a alertRuleDo) Create(values ...*model.AlertRule) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a alertRuleDo) CreateInBatches(values []*model.AlertRule, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a alertRuleDo) Save(values ...*model.AlertRule) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a alertRuleDo) First() (*model.AlertRule, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertRule), nil
	}
}

func (a alertRuleDo) Take() (*model.AlertRule, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertRule), nil
	}
}

func (a alertRuleDo) Last() (*model.AlertRule, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertRule), nil
	}
}

func (a alertRuleDo) Find() ([]*model.AlertRule, error) {
	result, err := a.DO.Find()
	return result.([]*model.AlertRule), err
}

func (a alertRuleDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlertRule, err error) {
	buf := make([]*model.AlertRule, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a alertRuleDo) FindInBatches(result *[]*model.AlertRule, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a alertRuleDo) Attrs(attrs ...field.AssignExpr) IAlertRuleDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a alertRuleDo) Assign(attrs ...field.AssignExpr) IAlertRuleDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a alertRuleDo) Joins(fields ...field.RelationField) IAlertRuleDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a alertRuleDo) Preload(fields ...field.RelationField) IAlertRuleDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a alertRuleDo) FirstOrInit() (*model.AlertRule, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertRule), nil
	}
}

func (a alertRuleDo) FirstOrCreate() (*model.AlertRule, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlertRule), nil
	}
}

func (a alertRuleDo) FindByPage(offset int, limit int) (result []*model.AlertRule, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a alertRuleDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a alertRuleDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a alertRuleDo) Delete(models ...*model.AlertRule) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *alertRuleDo) withDO(do gen.Dao) *alertRuleDo {
	a.DO = *do.(*gen.DO)
	return a
}
